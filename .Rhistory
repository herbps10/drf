geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous() +
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
print(p)
}
if ("pension" %in% run){
######################
#####Pension 401(k) data set #######
######################
library(hdm)
data(pension)
pension<-pension[complete.cases(pension),]
X<-pension[1:nrow(pension), c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")]
W<-pension[1:nrow(pension),"e401", drop=F]
# Y=(Net Financial Assets, Net Non-401(k) Financial Assets, Total Wealth)
Y<-pension[1:nrow(pension),c("net_tfa", "net_nifa", "tw")]
#Y<-pension[2:nrow(pension),c( "tw"), drop=F]
Y<-scale(Y)
## As in cite(...) we consider the free wealth measures, Net Financial Assets, Net Non-401(k) Financial
## Assets and Total Wealth as the dependent variables.
## While citet(Hansen) use separate quantile regressions and cite(...) combine
## the wealth measures into one variable beforehand, we use the ability of Causal-DRF
## to estimate the CKTE of the three wealth measures in total.
testid<-c(1:10)
#
# i<-0
# witnesslist<-list()
# Ylist<-list()
# for (n in 8000){
#   i<-i+1
#   train_idx = sample(1:nrow(X)-1, n, replace=FALSE)
#
#   ## Focus on training data
#   Ytrain=as.matrix(Y[train_idx,, drop=F])
#   Wtrain<-as.matrix(W[train_idx,,drop=F])
#   #as.numeric(W[train_idx])
#   Xtrain=as.matrix(X[train_idx,])
#
#   fit <- drf(X=Xtrain, Y=Ytrain[,1,drop=F], W=Wtrain, num.trees = 4000, ci.group.size = 100)
#
#
#   witnesslist[[i]]<- predict_witness(fit, alpha = 0.05, newdata = x, newtreatment = matrix(1))
#   Ylist[[i]] <- Ytrain[,1,drop=F]
# }
#
# for (i in 1:length(witnesslist)){
#
#   witness <- witnesslist[[i]]
#   data <- tibble(
#     Y     = Ylist[[i]],
#     w     = witness[1, ],
#     lower = witness[2, ],
#     upper = witness[3, ]
#   )
#
#
#   p <- data %>%
#     ggplot(aes(x = rowSums(Y), y = w)) +
#     geom_line(size = 1.5) +  # Thicker main line
#     geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
#     geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
#     geom_hline(yintercept = 0, size = 1.5)+
#     scale_x_continuous(limits =  range(Ylist[[length(witnesslist)]])) +
#     scale_y_continuous(limits = c(-0.4,0.4)) +
#     labs(y = NULL) +  # Remove y-axis label+
#     theme(
#       axis.title = element_text(size = 14),  # Increase axis title size
#       axis.text = element_text(size = 12)    # Increase axis text size
#     )
#   print(p)
# }
train_idx =setdiff(1:nrow(X),testid)#sample(2:nrow(X), 8000, replace=FALSE)
## Focus on training data
Ytrain=as.matrix(Y[train_idx,, drop=F])
Wtrain<-as.matrix(W[train_idx,,drop=F])
#as.numeric(W[train_idx])
Xtrain=as.matrix(X[train_idx,])
fit <- drf(X=Xtrain, Y=Ytrain, W=Wtrain, num.trees = 4000, ci.group.size = 100)
x<-as.matrix(pension[testid[1], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
### Request 1: Can we make a new option for newtreatmnet that directly gives us wx?
### Request 2: Can we somehow output the witness function?
wx<-wx1 - wx0
wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-10,10) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
}
warnings()
###Change testpoint here
x<-as.matrix(pension[testid[2], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
### Request 1: Can we make a new option for newtreatmnet that directly gives us wx?
### Request 2: Can we somehow output the witness function?
wx<-wx1 - wx0
wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-10,10) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
x
pension[testid[2], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")]
pension[, c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")]
pension[testid, c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")]
###Change testpoint here
x<-as.matrix(pension[testid[7], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
### Request 1: Can we make a new option for newtreatmnet that directly gives us wx?
### Request 2: Can we somehow output the witness function?
wx<-wx1 - wx0
wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-10,10) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
}
###Change testpoint here
x<-as.matrix(pension[testid[10], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
### Request 1: Can we make a new option for newtreatmnet that directly gives us wx?
### Request 2: Can we somehow output the witness function?
wx<-wx1 - wx0
wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-10,10) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
predict.drf
drf:::predict.drf
drf:::get_causal_bootstrap_sample_weights
source("C:/Users/Jeff/OneDrive/Dokumente/Studium/PhD/Projects with Marc/Github/drf/r-package/drf/R/predict.R")
load("C:/Users/Jeff/OneDrive/Dokumente/Studium/PhD/Projects with Marc/Github/drf/Results.RData")
hist0(Ytrain[,1])
hist(Ytrain[,1])
hist(Ytrain[,2])
hist(Ytrain[,3])
dim(Xtrain)
head(Xtrain)
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-5,5) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
library(kernlab)
library(drf)
library(Matrix)
library(dplyr)
library(doParallel)
library(doRNG)
library(parallel)
library(ggplot2)
library(dplyr)
library(ggpubr)
library(drf)
library(ggplot2)
library(fastDummies)
library(Hmisc)
library(gridExtra)
library(designmatch)
source("compute_causaldrf_vimp.R")
set.seed(10)
#run <- c("toy_examples", "wage", "lalonde", "pension")
run<-"pension"
###Change testpoint here: We use 1 and 10
x<-as.matrix(pension[testid[10], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
#x<-as.matrix(pension[testid, c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
#wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
#wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
#wx<-wx1 - wx0
wx<-predict(fit, newdata=x, newtreatment=NULL, bootstrap=F)$weights
#wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
#wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
#wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
wxSb<-predict(fit, newdata=x, newtreatment=NULL, bootstrap=T)$weights
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-5,5) ) + # range(yseq)
scale_y_continuous(limits = c(-0.4,0.4)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-5,5) ) + # range(yseq)
scale_y_continuous(limits = c(-0.2,0.2)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
x
###Change testpoint here: We use 1 and 10
x<-as.matrix(pension[testid[1], c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
#x<-as.matrix(pension[testid, c("age", "inc", "fsize", "educ", "marr", "twoearn", "hown", "db", "pira")])
#wx0<- predict(fit, newdata=x, newtreatment=0, bootstrap=F)$weights
#wx1<- predict(fit, newdata=x, newtreatment=1, bootstrap=F)$weights
#wx<-wx1 - wx0
wx<-predict(fit, newdata=x, newtreatment=NULL, bootstrap=F)$weights
#wxSb0<- predict(fit, newdata=x, newtreatment=0, bootstrap=T)$weights
#wxSb1<- predict(fit, newdata=x, newtreatment=1, bootstrap=T)$weights
#wxSb<-lapply(1:length(wxSb0), function(j) wxSb1[[j]] - wxSb0[[j]]  )
wxSb<-predict(fit, newdata=x, newtreatment=NULL, bootstrap=T)$weights
bandwidth_Y <- fit$bandwidth
k_Y <- rbfdot(sigma = 1/(2*bandwidth_Y^2) )
##Do Test of equality
Ky <- t(kernlab::kernelMatrix(k_Y, Ytrain, y = Ytrain))
H0list<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Ky%*%t(w-wx)) ))
q<-quantile(H0list, 1-0.05)
teststat<-as.numeric(wx%*%Ky%*%t(wx))
print(ifelse(teststat >= q, "We reject at 5%", "We do not reject at 5%" )) ##We reject a t the 5 % level!
p<-list()
##Only plot first dimension
for (j in 1:3){
bandwidth_Yj <- drf:::medianHeuristic(Ytrain[,j])
k_Yj <- rbfdot(sigma = 1/(2*bandwidth_Yj^2) )
Kyj <- kernlab::kernelMatrix(k_Y, Ytrain[,j], y =  Ytrain[,j])
H0listj<-do.call(c, lapply(wxSb, function(w) as.numeric((w-wx)%*%Kyj%*%t(w-wx)) ))
qj<-quantile(H0listj, 1-0.05)
##Make this into an actual function!!! and then a grid from min to max of Y.
fvals<- function(y){
Kyjf <- kernlab::kernelMatrix(k_Yj, Ytrain[,j], y =  y)
return(as.numeric(unlist(wx%*%Kyjf)))
}
yseq<-seq(min(Ytrain[,j]), max(Ytrain[,j]), by=0.005    )
data <- tibble(
Y     = yseq,
w     = fvals(yseq),
lower = fvals(yseq)-sqrt(qj),
upper = fvals(yseq)+sqrt(qj)
)
p[[j]] <- data %>%
ggplot(aes(x = Y, y = w)) +
geom_line(size = 1.5) +  # Thicker main line
geom_line(aes(y = lower), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_line(aes(y = upper), lty = 2, size = 1.5) +  # Thicker dashed lines
geom_hline(yintercept = 0, size = 1.5)+
scale_x_continuous(limits = c(-5,5) ) + # range(yseq)
scale_y_continuous(limits = c(-0.2,0.2)) +
labs(y = NULL) +  # Remove y-axis label+
theme(
axis.title = element_text(size = 14),  # Increase axis title size
axis.text = element_text(size = 12)    # Increase axis text size
)
}
grid.arrange(p[[1]], p[[2]], p[[3]], ncol = 3)
vimp
sort(vimp)
